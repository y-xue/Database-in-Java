In lab1, the design decisions are usually made when choosing data structures. For example, I prefer to use ArrayList instead of a array, since ArrayList is flexible at its capability and operations such as Get and Add are all O(1).In Class TupleDesc, who has a variable called tDItemList that contains TDItems, I create a new constructor that takes a tDItemList as parameter. By doing this, instead of re-calculating typeArray and fieldArray every time when we create new TupleDesc object from an existing one, we can create it by just passing tDItemList of the latter one. This design also makes it easier to merger two TupleDecs objects.In Class Catalog, we need a map with table names being keys and tables being values. However, there are a lot of read operations from the map given a table ID, not table name. To make these operations more efficient, I create another map keeping track of the mapping from table ID to table name. This design is based on the assumption that different table names must have different table ID, which I think is true.The Heap classes don’t involve with any fancy data structure. The difficult part is understanding how the files are stored on disk and how to read and organize them. After understanding the whole design, everything becomes straightforward. The only fancy thing, if there has to be one, it’s the bit operations. By reading lab requirement sheet, I thought tuples in pages come with their headers. It takes me quite a while to figure out that headers and tuples are stored separately. Then everything makes sense and this code does the trick:((headerByte >> (slot_i % 8)) & 1) == 1It takes me 15-20h to finish the first lab. The most difficult part is understanding the design of SimpleDB.